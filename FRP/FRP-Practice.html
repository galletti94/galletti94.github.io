<!DOCTYPE html>
<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<!--
<link href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css" rel="stylesheet">
-->
<title> Functional Reactive Programming </title>
<style>
button:focus{
  outline:none !important;
}
</style>
<script
src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js">
</script>
<script
src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js">
</script>
<script
src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js">
</script>
<script
src="https://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.53/Bacon.min.js">
</script>


<hr size="3">

<div class="container" style="text-align:center">
  <h2> Functional Reactive Programming </h2>
  <h4> Some Fun Buttons by <a href="http://gallettilance.org">Lance Galletti</a> </h4>
</div>

<hr size="3">

<br>

<div class="container">
  <h4 align="justify"> Here are some fun counters I made to get familiar with how streams work in Bacon JS. At first it was confusing to have the object oriented constructs meddling with the functional style. After spending some time writing code it seems like you can still efficiently write functional code in JS. I hope that reading this will help you skip some of the mental acrobatics that come with adjusting/translating familiar concepts to the constructs of a new language </h4>
</div>

<br>
<br>
<br>
<br>
<br>

<div class="container-fluid">

<div class="container" style="text-align:center">
  <h2> Simple counter </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> This first counter is the same as on the Bacon.js tutorial page with the addition of a FRP style reset button </h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:150px; overflow:hidden; resize:none">
var up = $('#up').asEventStream('click');
var down = $('#down').asEventStream('click');
var reset = $('#reset').asEventStream('click');

var theCounts1 = up.map(1).merge(down.map(-1)).merge(reset.map(0)).scan(0, function(x, y) {if (y === 0) {return 0} else { return x + y }});
//assign value to counter
theCounts1.assign($('#theCounts1'), 'text');
</textarea>
</div>

<div class="row">
<div class="col-md-12">
<center>
<p id="theCounts1" class="h1">00</p>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="up"
 type="button"
 class="btn btn-default btn-lg"
>UP</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
id="down" 
type="button" class="btn btn-default btn-lg"
 >Down</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="reset"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="3">


<br>
<br>
<br>

<div class="container" style="text-align:center">
  <h2> Square counter </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> This counter is simply applying a map function to the next stream element. Here the map is the square function but it could be any univariate function - simply change the return value of square(x). No need to keep track of previous values here because the input stream is responsible for telling our mapping what it should evaluate. If the input stream is more complex, it is there that the previous values should be recorded.  </h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:250px; overflow:hidden; resize:none">
var sqNext = $('#sqNext').asEventStream('click');
var sqPrev = $('#sqPrev').asEventStream('click');
var reset = $('#resetSq').asEventStream('click');

function square(x) {
    return x*x
}

var theCounts6 = sqNext.map(1).merge(reset.map(0)).merge(sqPrev.map(-1)).scan(0, function(x,y) {if (y === 0) {return 0} else {return x + y}}).scan(0, function(x, y) {return square(y)});

theCounts6.assign($('#theCounts6'), 'text');

</textarea>
</div>

<br>
<br>

<div class="row">
<div class="col-md-12">
<center>
<p id="theCounts6" class="h1">00</p>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="sqNext"
 type="button"
 class="btn btn-default btn-lg"
>Next Square</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="sqPrev"
 type="button"
 class="btn btn-default btn-lg"
>Prev Square</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="resetSq"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<br>
<br>
<br>


<div class="container" style="text-align:center">
  <h2> Factorial counter </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> This counter is more complex because you need to keep track of a rolling product of numbers and multiply it by the next integer when Next is pressed or divide by the previous when Prev is pressed. You need to map the stream of clicks in such a way that you continuously dynamically update the counter by processing the next click while not recomputing everything </h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:190px; overflow:hidden; resize:none">
var factNext = $('#factNext').asEventStream('click');
var factPrev = $('#factPrev').asEventStream('click');
var reset = $('#resetFact').asEventStream('click');

// need to create an input stream of "consecutive pairs" of integers to build fact and reverse fact
var theCounts2 = factNext.map(1).merge(reset.map(0)).merge(factPrev.map(-1)).scan([0, 1], function(x,y) {if (y === 0) {return [0, 1]} else {return [x[1], x[1] + y]}}).scan(1, function(x, y) {if ( y[0] === 0 ) {return 1} else {if (y[0]>= y[1]) {return x/y[0] } else {return x*y[1]}}});

theCounts2.assign($('#theCounts2'), 'text');
</textarea>
</div>
  
<div class="row">
<div class="col-md-12">
<center>
<p id="theCounts2" class="h1">00</p>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="factNext"
 type="button"
 class="btn btn-default btn-lg"
>Next Fact</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="factPrev"
 type="button"
 class="btn btn-default btn-lg"
>Prev Fact</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="resetFact"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="3">

<br>
<br>
<br>

<div class="container" style="text-align:center">
  <h2> Fibonnacci counter </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> Similar to the Factorial counter, we need to keep track of two values so that they can be joined to form the next. To build to Prev function, we could have kept track of a third number but by observing the arithmetic relation between consecutive fibs you can reconstruct the prev fib through subtraction. </h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:190px; overflow:hidden; resize:none">
var fibNext = $('#fibNext').asEventStream('click');
var fibPrev = $('#fibPrev').asEventStream('click');
var reset = $('#resetFib').asEventStream('click');

// similar to fact, need to keep in memory the previous value so that reverse fib can work
var  theCounts3 = fibNext.map(1).merge(reset.map(0)).merge(fibPrev.map(-1)).scan([0, 1], function(x,y) {if (y === 0) {return [0, 1]} else {if (y < 0) { return [x[1]-x[0], x[0]] } else {return [x[1], x[1] + x[0]]}}}).scan(1, function(x, y) {if ( y[0] === 0 ) {return 0} else {if (y[0]>= y[1]) {return y[0]} else {return y[1]}}});

theCounts3.assign($('#theCounts3'), 'text');
</textarea>
</div>

<div class="row">
<div class="col-md-12">
<center>
<p id="theCounts3" class="h1">00</p>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="fibNext"
 type="button"
 class="btn btn-default btn-lg"
>Next Fib</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="fibPrev"
 type="button"
 class="btn btn-default btn-lg"
>Prev Fib</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="resetFib"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<br>
<br>
<br>

<div class="container" style="text-align:center">
  <h2> Fold left counter on N </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> This one was super fun! The goal is to build a counter that applies a foldleft on a stream on inputs (here the integers - but this can easily be changed). The difficult part is the Prev function because it requires your fold function to be invertible. Also to avoid repeating some code, I built a higher order function that takes in your input stream, an initial value, a fold function and its inverse and applies fold accordingly. It turns out that the each of the 4 functions I chose for this example had their inverse be one of these functions - less code repetition! You'll notice that the product counter is identical to the factorial counter and the sum counter, although somewhat similar, is distinct from the fib counter</h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:750px; overflow:hidden; resize:none">
// some options for the folding function
function divide(x, y) {
    return x/y
}

function diff(x, y) {
    return x-y
}

function mult(x, y) {
    return x*y
}

function sum(x, y) {
    return x+y
}

var foldNext = $('#foldNext').asEventStream('click');
var foldPrev = $('#foldPrev').asEventStream('click');
var reset = $('#resetFold').asEventStream('click');

var s = foldNext.map(1).merge(reset.map(0)).merge(foldPrev.map(-1)).scan([0, 1], function(x,y) {if (y === 0) {return [0, 1]} else {return [x[1], x[1] + y]}});

// higher order function - takes an initial value, a function (and its inverse) and applies a foldleft on the integer stream
function myfunc(st, init, f, inv) {
    return st.scan(init, function(x, y) {if ( y[0] === 0 ) {return init} else {if (y[0] >= y[1]) {return inv(x, y[1])} else {return f(x, y[0])}}})
}

var theCounts_sum = myfunc(s, 0, sum, diff);
var theCounts_mult = myfunc(s, 1, mult, divide);
var theCounts_div = myfunc(s, 1, divide, mult);
var theCounts_diff = myfunc(s, 0, diff, sum);
    
theCounts_sum.assign($('#theCounts_sum'), 'text');
theCounts_mult.assign($('#theCounts_mult'), 'text');
theCounts_div.assign($('#theCounts_div'), 'text');
theCounts_diff.assign($('#theCounts_diff'), 'text');
</textarea>
</div>

<br>
<br>


<div class="row">
<div class="col-md-3">
  <center>
    <p> sum </p>
    <p id="theCounts_sum" class="h1">00</p>
  </center>
</div>
<div class="col-md-3">
  <center>
    <p> product </p>
    <p id="theCounts_mult" class="h1">00</p>
  </center>
</div>
<div class="col-md-3">
  <center>
    <p> Quotient </p>
    <p id="theCounts_div" class="h1">00</p>
  </center>
</div>
<div class="col-md-3">
  <center>
    <p> Difference </p>
    <p id="theCounts_diff" class="h1">00</p>
  </center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="foldNext"
 type="button"
 class="btn btn-default btn-lg"
>Next Fold</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="foldPrev"
 type="button"
 class="btn btn-default btn-lg"
>Prev Fold</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="resetFold"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<br>
<br>
<br>

<div class="container" style="text-align:center">
  <h2> Rolling average on N </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> Here we need to keep track of three values: instead of computing the length of the stream at every step, we keep track of the last number of integers we have seen so far (for the Prev button) and the current number of integer we have seen so far (for the Next button), and we also keep track of a rolling folding function (sum and its inverse diff) to be divided by the number of integers seen so far. </h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:170px; overflow:hidden; resize:none">
var rollNext = $('#rollNext_m').asEventStream('click');
var rollPrev = $('#rollPrev_m').asEventStream('click');
var reset = $('#resetRoll_m').asEventStream('click');

var theCounts5 = rollNext.map(1).merge(reset.map(0)).merge(rollPrev.map(-1)).scan([0, 1, 0], function(x,y) {if (y === 0) {return [0, 1, 0]} else {if (y < 0) {return [x[0]+y, x[1]+y, diff(x[2], x[0])]} else {return [x[0] + y, x[1] + y, sum(x[2], x[1])]}}}).scan(0, function(x, y) {return y[2]/y[1]});

theCounts5.assign($('#theCounts5'), 'text');
</textarea>
</div>

<br>
<br>

<div class="row">
<div class="col-md-12">
<center>
<p id="theCounts5" class="h1">00</p>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="rollNext_m"
 type="button"
 class="btn btn-default btn-lg"
>Next Mean</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="rollPrev_m"
 type="button"
 class="btn btn-default btn-lg"
>Prev Mean</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="resetRoll_m"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="2">

<br>
<br>
<br>

<div class="container" style="text-align:center">
  <h2> Fold left2 counter on (N, N) </h2>
</div>

<br>

<div class="container">
<h4 align="justify"> Similarly to foldleft, we want to fold two streams at once through a fold function f of 3 variables (the initial value, the value of the first stream, the value of the second stream). Maybe not the cleanest code I have written, but the idea is that for each stream we want to keep track of previous values. The inverse is applied to the first [stream1Value1, Stream2Value1] pair and the fold function is applied to the second pair. In case of more complex input streams, we can deal with some backtracking. </h4>
</div>

<div class="container" sytle="text-align:center">
<textarea class="container" style="font-weight:bold; background-color:#95B9D9; height:690px; overflow:hidden; resize:none">
var foldNext = $('#fold2Next').asEventStream('click');
var foldPrev = $('#fold2Prev').asEventStream('click');
var reset = $('#resetFold2').asEventStream('click');

var s1 = foldNext.map(1).merge(reset.map(0)).merge(foldPrev.map(-1)).scan([0, 1], function(x,y) {if (y === 0) {return [0, 1]} else {return [x[1], x[1] + y]}});
var s2 = foldNext.map(1).merge(reset.map(0)).merge(foldPrev.map(-1)).scan([0, 1], function(x,y) {if (y === 0) {return [0, 1]} else {return [x[1], x[1] + y]}});

// higher order function - takes an initial value, a function (and its inverse) and applies a foldleft on a combination of the 2 integer streams
function myfunc2(st1, st2, init, f, inv) {
    return st1.combine(st2, function (x, y) {return [x, y]}).scan(init, function(x, y) {if ( y[0][0] === 0 ) {return init} else {if (y[0][0] >= y[0][1]) {return inv(x, y[0][0], y[1][0])} else {return f(x, y[0][1], y[1][1])}}})
}

function sumSq(x, y, z) {
    return x + y*z
}

function sumSqInv(x, y, z) {
    return x - y*z
}

function sumInvSq(x, y, z) {
    return x + 1/(y*z)
}

function sumInvSqInv(x, y, z) {
    return x - 1/(y*z)
}

var theCounts_sumSq = myfunc2(s1, s2, 0, sumSq, sumSqInv);
var theCounts_sumInvSq = myfunc2(s1, s2, 1, sumInvSq, sumInvSqInv);
    
theCounts_sumSq.assign($('#theCounts_sumSq'), 'text');
theCounts_sumInvSq.assign($('#theCounts_sumInvSq'), 'text');
</textarea>
</div>


<br>
<br>


<div class="row">
<div class="col-md-6">
  <center>
    <p> sum of Squares </p>
    <p id="theCounts_sumSq" class="h1">00</p>
  </center>
</div>
<div class="col-md-6">
  <center>
    <p> sum of 1/Squares </p>
    <p id="theCounts_sumInvSq" class="h1">00</p>
  </center>
</div>
</div><!--class-row-->

<hr size="2">

<div class="row">
<div class="col-md-4">
<center>
<button
 id="fold2Next"
 type="button"
 class="btn btn-default btn-lg"
>Next Fold2</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="fold2Prev"
 type="button"
 class="btn btn-default btn-lg"
>Prev Fold2</button>
</center>
</div>
<div class="col-md-4">
<center>
<button
 id="resetFold2"
 type="button"
 class="btn btn-default btn-lg"
>Reset</button>
</center>
</div>
</div><!--class-row-->

<hr size="2">

</div>


<script
 src="./JS/theCounter_bacon.js">
</script>


</body>
</html>

